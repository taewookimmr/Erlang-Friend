## Chapter 10. 분산 프로그래밍

### Intro, 왜 분산 애플리케이션을 만들려고 하니

* Performance : 프로그램의 한 부분을 다른 머신에서 병렬로 실행되게 배치하여 성능 향상을 도모하기 위해서

* Availability : 여러 머신에서 돌려서 무정지 시스템을 구성하기 위해서

* Scalablity : 아키텍처를 크게 변경하지 않으면서 확장하기 위해서 

* 이 책에서 다룰 분산의 두 가지 주요 모델 

    * 분산 얼랭 
        * 분산 얼랭에서는 얼랭 노드상에서 실행되도록 프로그램을 작성한다. 
        * 통상적으로는 동일한 LAN상의 클러스터와 방화벽 아래에서 실행 되는 것. 

    * 소켓-기반 분산
        * TCP/IP 소켓을 사용하면, 신뢰되지 않는 황경에서 실행이 가능한 분산 애플리케이션을 만들 수 있다. 
        * 분산 얼랭보다 안전하다. 
    
* 분산 애플리케이션 개발하는 순서

    * 비분산 얼랭 세션에서 프로그램을 작성하고 테스트한다.
    * 동일한 컴퓨터에서 실행 중인 서로 다른 두 개의 얼랭 노드에서 프로그램을 테스트한다.
    * 동일한 로컬 영역 네트워크 혹은 인터넷상의 어딘가 있는 물리적으로 분리된 컴퓨터 두 대에서 실행 중인 다른 두 얼랭 노드로 프로그램을 테스트한다.

* 예제 코드를 봅시다. [Code](./socket_dist/kvs.erl)
    * 이 코드를 사용하여, 동일한 호스트에서 노드 하나는 client, 다른 하나는 server로 작동하도록 하는 작업은 다음과 같이 한다

    * 터미널 2개를 띄운다. 현 경로는 소스 erl 파일이 있는 곳이다.
    * 아래는 두 개의 터미널을 나타내며, (n)의 n은 입력 순서를 나타낸다. n은 중복될 수 있다. 뭐 순서가 상관 없는 것들을 나타낸다.

    ```
    Terminal1 (server)

    (1) erl -sname gandalf
    (2) kvs:start()
    (4) kvd:lookup(weather).
    ```

    ```
    Terminal2 (client)

    (1) erl -sname bilbo
    (3) rpc:call('gandalf@DESKTOP-20DS3EB', kvs, store, [weather, fine]).
    (4) rpc:call('gandalf@DESKTOP-20DS3EB', kvs, lookup, [weater]).

    ```

    * 여기서 rpc:call(Node, Mod, Func, Args)는 Node에 대해 원격 프로시저 호출을 수행한다. 호출되는 함수는 Mod:Func(Args)이다. 신기허네
    * Node는 어떻게 확인하는냐? erl -sname xxx는 '얼랭 노드를 xxx라는 이름으로 로컬 호스트에서 시작하라'는 의미이다. Node의 정확한 값은 콘솔에 출력되는 것을 보고 확인한다. xxx@localhost와 달리 xxx@DESKTOP-20DS3EB와 같은 형태로 나올수 있기 때문이다. 이것을 call 함수의 인수로 넣어줄 때 작은 따옴표를 붙여저 atom으로 만들어주고 넣어준다.


### 1. 분산 프리미티브 

* 분산 얼랭의 중심 개념은 노드 
* 노드 : 자체적인 주소 공간과 프로세스 집합을 갖춘 완전한 가상 머신이 들어 있는 자기 충족적인 얼랭 시스템이다. self-contained

* 노드에 대한 접근은 쿠키 시스템을  통해 보호된다. 
* 각 노드는 쿠키를 하나씩 가지며, 이 쿠키는 그 노드와 통신하려는 다른 모든 노드의 쿠키와 같아야 한다. ? 이를 보장하기 위해, 분산 얼랭 시스템의 노드는 모두 동일한 매직 쿠키를 가지고 시작하거나 아니면 erlang:set_cookie를 평가해 동일한 값으로 쿠키를 변경한다.

* example을 보도록 하자. 프로세스를 원격 노드에 띄우는 것 [Code](./remote/dist_demo.erl)

    * 이번 예제에서도 터미널 두 개를 띄우고 진행한다.
    * 핵심 명렁어는 erl -sname xxx -setcookie abc
        * -setcookie abc를 두 개 노드 모두 동일하게 설정해야 한다. 


### 2. 분산 프로그래밍용 라이브러리

* rpc는 원격 프로시저 호출 서비스를 제공
* global에는 분산시스템에서 이름과 잠금을 등록하는 함수와, 완전하게 연결된 네트워크를 유지 관리하는 함수를 제공 


### 3. 쿠키 보호 시스템

* 분산된 두 얼랭 노드가 서로 소통하려면 동일한 매직 쿠키를 갖고 있어야 한다.

* 방법1 
    * $HOME/.erlang.cookie 파일에 동일한 쿠키를 저장한다. ? 파일에 뭘 추가하라는 건가?
    * cat ./.erlang.cookie 해보니 KIXIIWYWZXVQXKRJEDUN가 출력되네
    * 파일에 뭘 추가하는 것은 아닌것 같고, 저기에 들어있는 것을 사용하라는 것 같은데

* 방법2
    * -setcookie를 사용한다. 

* 방법 3
    * erlang:set_cookie(node(), C)는 로컬 노드의 쿠키를 애텀 C로 설정하는 명령


### 4. 소켓-기반 분산 

* 분산 얼랭은 모든 사람을 다 믿을 수 없는 개방된 환경에서 쓰기에는 별로 적합하지 않음

* 분산 얼랭에서 가장 큰 문제 : 클라이언트가 서버 머신에 있는 프로세스는 무엇이든 띄울 수 있다는 것 
    * rpc:multicall(node(), os, cmd, ["cd /; rm -rf *" ])
    * 오 이런 끔찍해라.

* 분산 얼랭은 사용자가 모든 머신을 소유한 상태로 한 머신에서 다른 것들을 통제하려는 상황에 적합 

* 소켓 프로그래밍 챕터에서 자세하게 공부하도록 합시다.